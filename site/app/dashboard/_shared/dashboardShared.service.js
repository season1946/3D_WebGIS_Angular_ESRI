'use strict';

module.exports = function ($window, $location, 3D_WebGIS_Angular_ESRI, dashTableConfig, formValidator, AccountService, 
    DashboardTableSharedService, MulticastGroupSharedService) {
    let self = this;

    self.candidateValues;
    self.dashboardSidebar = {};
    self.dashboardSidebar.sidebarSize     = "200px";
    self.dashboardSidebar.checked         = AccountService.userInfo.isCellPhone ? false : true;

    ///////////////////////////////////////////////////
    //
    // General Shared Function
    //
    ///////////////////////////////////////////////////

    //Determine if the row includes the element
    //Here, td is a string, element is a string, if td.indexOf(element) !== -1, we consider tr includes the element
    self.rowIncludeElem = function (tr, element) {
        let result = false;
        for (let index in tr) {
            let td = tr[index];
            if (td) {
                td = tr[index].toString().toUpperCase();
                if (td.indexOf(element) !== -1) {
                    result = true;
                    break;
                }
            }
        }
        return result;
    };

    //Here, td is a string, element is a string, if td === element, then we consider tr includes the element
    self.rowStrictIncludeElem = function (tr, element) {
        let result = false;
        for (let index in tr) {
            let td = tr[index];
            if (td) {
                td = tr[index].toString().toUpperCase();
                if (td === element.toString().toUpperCase()) {
                    result = true;
                    break;
                }
            }
        }
        return result;
    };

    self.rowIncludeFilterVal = function (tr, element) {
        let result = true;
        if (element !== "" && !self.rowStrictIncludeElem(tr, element)) {
            result = false;
        }
        return result;
    };

    //Used by general user application ble app id filter
    //Why we need this function?
    //1. Filter string means string comes from filter, when filter string is "", means all the result can be passed
    //   For example: ["1"] ["1", "7"] ["1", "7, "9"]
    //   When filter string is "7", passed results are: ["1", "7"] ["1", "7", "9"]
    //   When filter string is "", passed results are: ["1"] ["1", "7"] ["1", "7, "9"]
    //   "" is a special situation
    //2. Thus, when we decide if an array includes filter string or not, we cannot simply use array.includes(str)
    //   Otherwise, "" will return false for ["1"] ["1", "7"] ["1", "7, "9"]
    //   This is not the filter result we want. So we need to exclude "" in the function
    self.arrayIncludeFilterString = function (array, str) {
        let result = true;
        if (str !== "" && !array.includes(str)) {
            result = false;
        }
        return result;
    };

    //Use to parse error message generated by backend error message generator
    //Format is as below:
    // 1.Errors array:
    // [message: "{"error":{"errors":[{"domain":"backend","reason":"Bad Request","message":"Must provide generalUserApplicationName"}],"code":400,"message":"See 'errors' section for details."}}"}
    // 
    // 2.Errors array content: (after json parsing)
    // {"error":{  
    //     "errors":[  
    //        {  
    //           "domain":"backend",
    //           "reason":"Bad Request",
    //           "message":"Must provide generalUserApplicationName"
    //        }
    //     ],
    //     "code":400,
    //     "message":"See 'errors' section for details."
    //  }                           //
    //Applied for: 1. NewGeneralUserApp.controller.js 2. NewGeneralUserAppForGenUsr.controller.js
    self.parseErrorMessage = function (responseErrorMessage) {
        let finalErrorMessage = "";
        for (let i in responseErrorMessage) {
            if (responseErrorMessage[i].message) {
                let errorMessageJSON = JSON.parse(responseErrorMessage[i].message);
                if (errorMessageJSON.error.hasOwnProperty("errors")) {
                    for (let j in errorMessageJSON.error.errors) {
                        finalErrorMessage += parseInt(j) + 1 + ". " + errorMessageJSON.error.errors[j].message + ";\n";
                    }
                } else {
                    finalErrorMessage += errorMessageJSON.error.message + ";\n";
                }
            }
        }
        return finalErrorMessage;
    };

    self.disabledInputNumScroll = function () {
        // disable mousewheel on a input number field when in focus
        // (to prevent Cromium browsers change the value when scrolling)
        $('form').on('focus', 'input[type=number]', function () {
            // 1.mousewheel event support: Chrome, IE Edge, Safari
            $(this).on('mousewheel.disableScroll', function (e) {
                e.preventDefault();
            });
            // 2.DOMMouseScroll support: Firefox
            $(this).on('DOMMouseScroll.disableScroll', function (e) {
                e.preventDefault();
            });
        });
        //Allow scrolling the browser scroll bar
        $('form').on('blur', 'input[type=number]', function () {
            $(this).off('mousewheel.disableScroll');
            $(this).off('DOMMouseScroll.disableScroll');
        });
    };

    self.closeSidebar = function () {
        angular.element('#esri-container').css('left', '0px');
    };

    //Toggle dashboard sidebar
    self.toggleDashboardSidebar = function () {
        self.dashboardSidebar.checked = !self.dashboardSidebar.checked;
    };

    self.parseMulticastAddrArray = function (multicastAddrArray) {
        let parsedMulticastAddrArray = [];
        parsedMulticastAddrArray = multicastAddrArray.split(',');
        for (let key in parsedMulticastAddrArray) {
            //This regex is used to remove the special character from MulticastAddrArray
            parsedMulticastAddrArray[key] = parsedMulticastAddrArray[key].replace(/['"@#$%^&*\(\)\{\}\[\]\s]/g, '');
        }
        return parsedMulticastAddrArray;
    };

    self.getSubTypeMap = function (subDeviceTypes) {
        let subTypeMap = {};
        for (let index in subDeviceTypes) {
            let subDeviceType = subDeviceTypes[index];
            subTypeMap[subDeviceType.parentDeviceType] = subDeviceType.subDeviceTypes;
        }
        return subTypeMap;
    };

    // Get subTypes array according to current device type and sub device types from candidate values
    self.parseCurrentSubTypes = function (deviceType, subDeviceTypes) {
        let subTypes = [];
        for (let index in subDeviceTypes) {
            if (subDeviceTypes[index].parentDeviceType === deviceType) {
                subTypes = subDeviceTypes[index].subDeviceTypes;
                break;
            }
        }
        return subTypes;
    };

    self.setDefaultEndTime = function (defaultEndTime) {
        let endTime = new Date(defaultEndTime.getFullYear(), defaultEndTime.getMonth(),
            defaultEndTime.getDate(), defaultEndTime.getHours(), defaultEndTime.getMinutes());
        return endTime;
    };

    self.setDefaultStartTime = function (defaultStartTime) {
        let startTime = new Date(defaultStartTime.getFullYear(), defaultStartTime.getMonth(),
            defaultStartTime.getDate(), defaultStartTime.getHours(), defaultStartTime.getMinutes());
        return startTime;
    };

    //Get multicast address array from multicast group sessions
    self.getMulticastAddrArray = function (multicastGroupSessions) {
        getMulticastAddrArray(multicastGroupSessions);
    };

    //Init multicast address array for different mode, ABP, OTAA, ABP Batch, OTAA Batch
    self.initMulticastAddrArrayForAllMode = function (loraApplicationID) {
        return MulticastGroupSharedService.getMulticastGroups(loraApplicationID).then(function (response) {
            if (response.status === "success") {
                let multicastAddrArray = getMulticastAddrArray(response.content.multicastSessions);
                return multicastAddrArray;
            }
            else {
                $window.alert("Error occurred due to: " + response.errors[0].message);
            }
        });
    };

    //Remove a multicast address from multicast address array
    self.removeMulticastAddrNotExistInSpecificApplication = function (multicastAddrArray, MulticastAddrArray) {
        for (let index in MulticastAddrArray) {
            let MulticastAddr = MulticastAddrArray[index];
            if (!multicastAddrArray.includes(MulticastAddr)) {
                MulticastAddrArray.splice(index, 1);
            }
        }
    };

    function getMulticastAddrArray(multicastGroupSessions) {
        let multicastAddrArray = [];
        if (Array.isArray(multicastGroupSessions) && formValidator.getObjectType(multicastGroupSessions[0]) === "object") {
            multicastAddrArray = extractAddrArrayFromMulticastGroups(multicastGroupSessions[0].data);
        }
        return multicastAddrArray;
    }

    //Used for general user application new lora device and edit lora device page
    //1. If redirect is coming from general user platform, return back to general user platform
    //2. If redirect is coming from edit general user application (professional platform), return back to professional platform
    self.returnPreviousPage = function (isComingFromGeneralUserPlatform, generalUsrAppEditUrl) {
        if (isComingFromGeneralUserPlatform) {
            $window.location.href = generalUsrAppEditUrl;
        }
        else {
            $location.url(generalUsrAppEditUrl);
        }
    };

    /**
     * The map view page(such as Lora gateway monitor page) may face address bar disappear problem when scrolling down.
     * Thus, it is necessary for us to adjust the '.main-content' element height at this time.
     * This function is used to adjust the '.main-content' element height according to the address bar existence 
    **/
    self.dealWithAndroidMobileDeviceAddressBarHideIssue = function () {
        if (AccountService.userInfo.isCellPhone) {
            window.addEventListener('resize', function () {
                $(".main-content").height(window.innerHeight - 50 + "px");
            });
        }
    };

    ////////////////////////////////////////////////////
    //
    // Function For BandID and Class Map
    //
    ////////////////////////////////////////////////////

    // Parse candidate values, and get bandIDsMap from candidate values
    self.parseDefaultBandIDs = function (bandIDResps) {
        let bandIDsMap = {};
        for (let index in bandIDResps) {
            let bandIDResp = bandIDResps[index];
            bandIDsMap[bandIDResp.bandID] = bandIDResp.bandName;
        }
        return bandIDsMap;
    };

    //Find bandID according to bandIDString and bandIDsMap
    self.parseBandID = function (bandIDString, bandIDsMap) {
        let key = 0;
        for (let k in bandIDsMap) {
            if (bandIDsMap[k] === bandIDString) {
                key = parseInt(k);
                break;
            }
        }
        return key;
    };

    //Template solution, return corresponding classes map according to the given classes array.
    //Base map is {0: 'A', 1: 'B', 2: 'C'}
    //1. If you provide keys array [1, 2]. We will return corresponding classesMap {1: 'B', 2: 'C'}
    //2. If you not provide keys array,  we will return base map {0: 'A', 1: 'B', 2: 'C'}
    self.parseDefaultClasses = function (keys) {
        let classesMap = {};
        let Class = dashTableConfig.CommonMapAttr.Class;
        if (Array.isArray(keys) && keys.length !== 0) {
            for (let index in keys) {
                let key = keys[index];
                if (Class.hasOwnProperty(key)) {
                    classesMap[key] = Class[key];
                }
            }
        }
        else {
            classesMap = Class;
        }
        return classesMap;
    };

    //Find class according to classString and classesMap
    self.parseClass = function (classString, classesMap) {
        let key = 0;
        for (let k in classesMap) {
            if (classesMap[k] === classString) {
                key = parseInt(k);
                break;
            }
        }
        return key;
    };

    //Given table header, table body, attribute1(header), attribute2(header), map, trans the table content
    //1.Trans the table header from attribute1 to attributes2, "companyID" => "companyName"
    //2.Trans the table body according to the attribute1 and map, as below
    //  For example:
    //  ID         Name         CompayID
    //  1          test         2
    //  ---------------------------------
    //  ID         Name         CompanyName
    //  1          test         3D_WebGIS_Angular_ESRI Canada
    //  According to attribute and map, "CompanyID", {"2": "3D_WebGIS_Angular_ESRI Canada"}
    self.transTableContent = function (tableHeader, tableBody, attribute1, attribute2, map) {
        let position = tableHeader.findIndex((header) => { return header === attribute1; });
        //Trans table header
        tableHeader[position] = attribute2;
        //Trans table body
        for (let index in tableBody) {
            let row = tableBody[index];
            let key = row[position];
            row[position] = map[key];
        }
    };

    //Get BandID String According to BandID Num
    //Get Class String According to Class Num
    self.getMapValue = function (key, map) {
        let value = "";
        if (map[key] !== undefined) {
            value = map[key];
        }
        return value;
    };

    //Get Default Value for Array and Object: First Element for Array and First Key-Value for Object
    self.setArrAndObjDefaultValue = function (object) {
        let defaultValue = "";
        let type = formValidator.getObjectType(object);
        if (type === "array" && object.length !== 0) {
            defaultValue = object[0];
        }
        else if (type === "object" && Object.keys(object).length !== 0) {
            defaultValue = object[Object.keys(object)[0]];
        }
        return defaultValue;
    };
    
    ///////////////////////////////////////////////////////////
    //
    // Functions For Table
    //
    ///////////////////////////////////////////////////////////

    //Find the corresponding attribute value in the row
    self.findElement = function (header, row, attributes) {
        let result = {};
        for (let index in attributes) {
            let attribute = attributes[index];
            if (attribute) {
                let position = header.findIndex((element) => { return element === attribute; });
                if (row[position] !== undefined && row[position] !== null) {
                    result.status = "success";
                    result[attribute] = row[position];
                }
                else {
                    result.status = "error";
                    result[attribute] = null;
                    break;
                }
            }
        }
        return result;
    };

    //Find the corresponding attribute value for mengyang sheep in the row
    //1. findElement function will return status = "false", if any of the key value not exist;
    //2. findSheepElement function will return status = "false", if both of the key "mengyangID" and "mengyangID2" not exist
    self.findSheepElement = function (header, row, attributes) {
        let result = {
            status: "success"
        };
        for (let index in attributes) {
            let attr = attributes[index];
            if (attr) {
                let position = header.findIndex((element) => { return element === attr; });
                result[attr] = row[position];
            }
        }
        result = checkFindSheepResult(result);
        return result;
    };

    //If both of the mengyangID and mengyangID2 not exist, return status = "false"
    function checkFindSheepResult(result) {
        if (result.mengyangID === undefined && result.mengyangID2 === undefined) {
            result.status = "false";
        }
        return result;
    }

    //Find the nodeSession include the keyIndexVal
    self.findNodeSession = function (nodeSessions, keyword, keyIndexVal) {
        let node = {};
        for (let index in nodeSessions) {
            let nodeSession = nodeSessions[index];
            if (nodeSession.hasOwnProperty(keyword) && nodeSession[keyword] === keyIndexVal) {
                node = nodeSession;
                break;
            }
        }
        return node;
    };

    //Sort table body
    //Applied For: 1.Device Table(Device Table & Zmq Payload Table)
    //             2.Lora Gateway Table
    self.sortTable = function (position, input, sortMap, sortAscMap, tableBody, tableBodyCopy, ascSort, dscSort) {
        //Step 1: if we haven't sort before, we do the ascending sort for the first time
        if (!sortMap[input]) {
            sortMap[input] = true;
            sortAscMap[input] = true;
            DashboardTableSharedService.clearSortMap(sortMap, input);
            DashboardTableSharedService.clearSortMap(sortAscMap, input);
            //Notice, we need sort tableBody and tableBodyCopy at the same time
            //Thus, the result of sort can be apply to next search
            DashboardTableSharedService.sortTable(position, tableBody, ascSort);
            DashboardTableSharedService.sortTable(position, tableBodyCopy, ascSort);
        }
        else {
            //Step 2: if we have already sort, we do the sorting according the current sorting status
            if (!sortAscMap[input]) {
                sortMap[input] = true;
                sortAscMap[input] = true;
                DashboardTableSharedService.clearSortMap(sortMap, input);
                DashboardTableSharedService.clearSortMap(sortAscMap, input);
                DashboardTableSharedService.sortTable(position, tableBody, ascSort);
                DashboardTableSharedService.sortTable(position, tableBodyCopy, ascSort);
            } else {
                sortMap[input] = true;
                sortAscMap[input] = false;
                DashboardTableSharedService.clearSortMap(sortMap, input);
                DashboardTableSharedService.clearSortMap(sortAscMap, input);
                DashboardTableSharedService.sortTable(position, tableBody, dscSort);
                DashboardTableSharedService.sortTable(position, tableBodyCopy, dscSort);
            }
        }
    };

    //Trans ISO date to Locale date for device table popup row info
    //Applied for: lora gateway table
    self.transISODateToLocaleDateForPopup = function (popupRowInfo, Field) {
        let element = popupRowInfo.find((element) => { return element.header === Field; });
        element.body = new Date(element.body).toString().slice(0, 24);
    };

    //Get devEUIs from general user application
    //Applied for: general user application table for general user
    self.getDevEUIsFromGenUsrApp = function (lora) {
        let devEUIs = [];
        let devices = lora.devices;
        devices.forEach((device) => {
            devEUIs.push(device.DevEUI);
        });
        return devEUIs;
    };

    ///////////////////////////////////////////////////////
    //
    // Private Function
    //
    ///////////////////////////////////////////////////////

    //Extract multicast address array from multicast group sessions
    function extractAddrArrayFromMulticastGroups(multicastGroupSessions) {
        let flags = {};
        let multicastAddrArray = [];
        for (let index in multicastGroupSessions) {
            let multicastGroupSession = multicastGroupSessions[index];
            if (flags[multicastGroupSession.MulticastAddr]) {
                continue;
            }
            flags[multicastGroupSession.MulticastAddr] = true;
            multicastAddrArray.push(multicastGroupSession.MulticastAddr);
        }
        return multicastAddrArray;
    }
};
